use super::*;
use crate::ASTCBlockSize;

#[test]
fn pack_block_4x4_0() {
    const INPUT_BLOCK: AstcBlock = AstcBlock {
        width: 4,
        height: 4,
        dual_plane: 0,
        weight_range: 8,
        weights: [
            1, 8, 14, 13, 3, 9, 9, 8, 0, 7, 7, 2, 1, 2, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0,
        ],
        color_component_selector: 0,
        partitions: 1,
        partition_id: 0,
        color_endpoint_pairs: 3,
        channels: 0,
        color_endpoint_modes: [8, 0, 0, 0],
        endpoint_range: 19,
        endpoints: [
            115, 107, 48, 178, 32, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ],
    };
    const EXPECTED_OUTPUT: [u32; 4] = [0xD6E70242, 0x3020B260, 0xEE484AA, 0x817BC991];

    let mut data = [0; 4];
    INPUT_BLOCK.pack(&mut data);

    assert_eq!(data, EXPECTED_OUTPUT)
}

#[test]
fn pack_block_4x4_1() {
    const INPUT_BLOCK: AstcBlock = AstcBlock {
        width: 4,
        height: 4,
        dual_plane: 0,
        weight_range: 7,
        weights: [
            7, 9, 10, 4, 1, 5, 3, 8, 1, 1, 11, 10, 5, 5, 5, 7, 4, 3, 2, 3, 4, 1, 3, 1, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 64, 0, 0, 0,
            21, 0, 0, 0, 21, 0, 0, 0,
        ],
        color_component_selector: 0,
        partitions: 1,
        partition_id: 0,
        color_endpoint_pairs: 3,
        channels: 21,
        color_endpoint_modes: [8, 21, 0, 21],
        endpoint_range: 20,
        endpoints: [
            226, 202, 117, 106, 58, 54, 127, 127, 0, 0, 0, 0, 21, 0, 0, 0, 21, 0,
        ],
    };

    const EXPECTED_OUTPUT: [u32; 4] = [0x95C50251, 0x6C74D4EB, 0x4D5B5780, 0xEB452F84];

    let mut data = [0; 4];
    INPUT_BLOCK.pack(&mut data);

    assert_eq!(data, EXPECTED_OUTPUT)
}

#[test]
fn pack_block_4x4_2() {
    const INPUT_BLOCK: AstcBlock = AstcBlock {
        width: 3,
        height: 3,
        dual_plane: 1,
        weight_range: 5,
        weights: [
            4, 4, 0, 1, 0, 0, 7, 5, 3, 7, 4, 6, 7, 5, 2, 2, 3, 5, 2, 4, 2, 4, 1, 2, 16, 0, 0, 0,
            16, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 21, 0, 0, 0, 64, 0, 0,
            0, 21, 0, 0, 0, 21, 0, 0, 0,
        ],
        color_component_selector: 0,
        partitions: 1,
        partition_id: 0,
        color_endpoint_pairs: 3,
        channels: 21,
        color_endpoint_modes: [8, 21, 0, 21],
        endpoint_range: 20,
        endpoints: [
            239, 222, 121, 115, 57, 55, 255, 0, 0, 0, 0, 0, 21, 0, 0, 0, 21, 0,
        ],
    };

    const EXPECTED_OUTPUT: [u32; 4] = [0xBDDF05BF, 0x6E72E6F3, 0xBF52D400, 0x24403DDC];

    let mut data = [0; 4];
    INPUT_BLOCK.pack(&mut data);

    assert_eq!(data, EXPECTED_OUTPUT)
}

#[test]
fn pack_block_4x4_3() {
    const INPUT_BLOCK: AstcBlock = AstcBlock {
        width: 3,
        height: 4,
        dual_plane: 1,
        weight_range: 4,
        weights: [
            1, 1, 3, 5, 3, 5, 3, 1, 5, 3, 5, 3, 3, 1, 4, 4, 4, 1, 5, 5, 0, 0, 0, 4, 38, 0, 0, 0, 0,
            0, 0, 0, 26, 0, 0, 0, 38, 0, 0, 0, 26, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0,
        ],
        color_component_selector: 0,
        partitions: 1,
        partition_id: 0,
        color_endpoint_pairs: 3,
        channels: 0,
        color_endpoint_modes: [8, 0, 0, 0],
        endpoint_range: 19,
        endpoints: [
            147, 155, 186, 118, 160, 28, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ],
    };

    const EXPECTED_OUTPUT: [u32; 4] = [0xB72705CF, 0xE60F675, 0xF85F6002, 0x93BDD5EE];

    let mut data = [0; 4];
    INPUT_BLOCK.pack(&mut data);

    assert_eq!(data, EXPECTED_OUTPUT)
}

#[test]
fn pack_block_4x4_4() {
    const INPUT_BLOCK: AstcBlock = AstcBlock {
        width: 4,
        height: 4,
        dual_plane: 0,
        weight_range: 6,
        weights: [
            0, 8, 2, 6, 9, 9, 9, 4, 1, 7, 8, 8, 8, 7, 9, 3, 5, 0, 4, 4, 4, 1, 4, 1, 26, 0, 0, 0,
            64, 0, 0, 0, 0, 0, 0, 0, 51, 0, 0, 0, 38, 0, 0, 0, 64, 0, 0, 0, 64, 0, 0, 0, 64, 0, 0,
            0, 0, 0, 0, 0, 21, 0, 0, 0,
        ],
        color_component_selector: 0,
        partitions: 1,
        partition_id: 0,
        color_endpoint_pairs: 3,
        channels: 64,
        color_endpoint_modes: [8, 0, 43, 21],
        endpoint_range: 20,
        endpoints: [
            148, 157, 90, 92, 59, 58, 191, 191, 43, 0, 0, 0, 64, 0, 0, 0, 21, 0,
        ],
    };

    const EXPECTED_OUTPUT: [u32; 4] = [0x3B290241, 0x7476B8B5, 0xDA3FB000, 0x509FE933];

    let mut data = [0; 4];
    INPUT_BLOCK.pack(&mut data);

    assert_eq!(data, EXPECTED_OUTPUT)
}

#[test]
fn test_block_layout_4x4() {
    let rgba_data = [255u8; 64];
    let mut pixels = [0.0f32; 256];

    let settings = ASTCSettings::alpha_slow(ASTCBlockSize::_4x4);
    let mode_ranker = ModeRankerASTC::new(&settings);
    mode_ranker.load_block_interleaved(&rgba_data, 0, 0, 16, &mut pixels);

    // Check first row of red channel (should use first 4 of 8 slots)
    assert_eq!(
        &pixels[0..8],
        &[255.0, 255.0, 255.0, 255.0, 0.0, 0.0, 0.0, 0.0]
    );

    // Check first row of green channel (offset by 64)
    assert_eq!(
        &pixels[64..72],
        &[255.0, 255.0, 255.0, 255.0, 0.0, 0.0, 0.0, 0.0]
    );
}

#[test]
fn test_block_layout_8x8() {
    // Alternating red, green, blue, yellow pixels
    const RGBA_DATA: [u8; 256] = [
        255, 0, 0, 255, 0, 255, 0, 255, 0, 0, 255, 255, 255, 255, 0, 255, 255, 0, 0, 255, 0, 255,
        0, 255, 0, 0, 255, 255, 255, 255, 0, 255, 255, 0, 0, 255, 0, 255, 0, 255, 0, 0, 255, 255,
        255, 255, 0, 255, 255, 0, 0, 255, 0, 255, 0, 255, 0, 0, 255, 255, 255, 255, 0, 255, 255, 0,
        0, 255, 0, 255, 0, 255, 0, 0, 255, 255, 255, 255, 0, 255, 255, 0, 0, 255, 0, 255, 0, 255,
        0, 0, 255, 255, 255, 255, 0, 255, 255, 0, 0, 255, 0, 255, 0, 255, 0, 0, 255, 255, 255, 255,
        0, 255, 255, 0, 0, 255, 0, 255, 0, 255, 0, 0, 255, 255, 255, 255, 0, 255, 255, 0, 0, 255,
        0, 255, 0, 255, 0, 0, 255, 255, 255, 255, 0, 255, 255, 0, 0, 255, 0, 255, 0, 255, 0, 0,
        255, 255, 255, 255, 0, 255, 255, 0, 0, 255, 0, 255, 0, 255, 0, 0, 255, 255, 255, 255, 0,
        255, 255, 0, 0, 255, 0, 255, 0, 255, 0, 0, 255, 255, 255, 255, 0, 255, 255, 0, 0, 255, 0,
        255, 0, 255, 0, 0, 255, 255, 255, 255, 0, 255, 255, 0, 0, 255, 0, 255, 0, 255, 0, 0, 255,
        255, 255, 255, 0, 255, 255, 0, 0, 255, 0, 255, 0, 255, 0, 0, 255, 255, 255, 255, 0, 255,
        255, 0, 0, 255, 0, 255, 0, 255, 0, 0, 255, 255, 255, 255, 0, 255,
    ];

    let settings = ASTCSettings::alpha_slow(ASTCBlockSize::_8x8);
    let mut mode_ranker = ModeRankerASTC::new(&settings);

    let mut mode_buffer = [0; 64];
    let mut pixels = [0.0; 256];

    mode_ranker.rank(&RGBA_DATA, 0, 0, 32, &mut mode_buffer, &mut pixels);

    // red channel
    for i in 0..64 {
        assert_eq!(pixels[i] as u8, RGBA_DATA[i * 4]);
    }
    // green channel
    for i in 0..64 {
        assert_eq!(pixels[64 + i] as u8, RGBA_DATA[i * 4 + 1]);
    }
    // blue channel
    for i in 0..64 {
        assert_eq!(pixels[128 + i] as u8, RGBA_DATA[i * 4 + 2]);
    }
    // alpha channel
    for i in 0..64 {
        assert_eq!(pixels[192 + i] as u8, RGBA_DATA[i * 4 + 3]);
    }
}

#[test]
fn rank_block_fast() {
    let rgba_data: [u8; 64] = [
        190, 190, 190, 255, 189, 189, 189, 255, 189, 189, 189, 255, 185, 177, 172, 255, 191, 191,
        191, 255, 189, 189, 189, 255, 188, 188, 188, 255, 185, 171, 164, 255, 188, 188, 188, 255,
        187, 187, 187, 255, 187, 187, 187, 255, 183, 162, 151, 255, 185, 185, 185, 255, 185, 185,
        185, 255, 183, 183, 183, 255, 184, 176, 171, 255,
    ];

    let expected_pixels: [f32; 256] = [
        190.0, 189.0, 189.0, 185.0, 0.0, 0.0, 0.0, 0.0, 191.0, 189.0, 188.0, 185.0, 0.0, 0.0, 0.0,
        0.0, 188.0, 187.0, 187.0, 183.0, 0.0, 0.0, 0.0, 0.0, 185.0, 185.0, 183.0, 184.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 190.0,
        189.0, 189.0, 177.0, 0.0, 0.0, 0.0, 0.0, 191.0, 189.0, 188.0, 171.0, 0.0, 0.0, 0.0, 0.0,
        188.0, 187.0, 187.0, 162.0, 0.0, 0.0, 0.0, 0.0, 185.0, 185.0, 183.0, 176.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 190.0, 189.0,
        189.0, 172.0, 0.0, 0.0, 0.0, 0.0, 191.0, 189.0, 188.0, 164.0, 0.0, 0.0, 0.0, 0.0, 188.0,
        187.0, 187.0, 151.0, 0.0, 0.0, 0.0, 0.0, 185.0, 185.0, 183.0, 171.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 255.0, 255.0, 255.0,
        255.0, 0.0, 0.0, 0.0, 0.0, 255.0, 255.0, 255.0, 255.0, 0.0, 0.0, 0.0, 0.0, 255.0, 255.0,
        255.0, 255.0, 0.0, 0.0, 0.0, 0.0, 255.0, 255.0, 255.0, 255.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    ];

    let expected_modes: [u32; 64] = [
        1005736776, 1006784585, 1004688455, 1007832650, 1027756231, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];

    let settings = ASTCSettings::alpha_fast(ASTCBlockSize::_4x4);
    let mut mode_ranker = ModeRankerASTC::new(&settings);
    let mut pixels = [0.0; 256];

    let mut mode_buffer = [0; 64];
    mode_ranker.rank(&rgba_data, 0, 0, 16, &mut mode_buffer, &mut pixels);

    assert_eq!(expected_pixels, pixels);
    assert_eq!(expected_modes, mode_buffer)
}

#[test]
fn test_compute_moments() {
    let pixels: [f32; 256] = [
        190.0, 189.0, 189.0, 185.0, 0.0, 0.0, 0.0, 0.0, 191.0, 189.0, 188.0, 185.0, 0.0, 0.0, 0.0,
        0.0, 188.0, 187.0, 187.0, 183.0, 0.0, 0.0, 0.0, 0.0, 185.0, 185.0, 183.0, 184.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 190.0,
        189.0, 189.0, 177.0, 0.0, 0.0, 0.0, 0.0, 191.0, 189.0, 188.0, 171.0, 0.0, 0.0, 0.0, 0.0,
        188.0, 187.0, 187.0, 162.0, 0.0, 0.0, 0.0, 0.0, 185.0, 185.0, 183.0, 176.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 190.0, 189.0,
        189.0, 172.0, 0.0, 0.0, 0.0, 0.0, 191.0, 189.0, 188.0, 164.0, 0.0, 0.0, 0.0, 0.0, 188.0,
        187.0, 187.0, 151.0, 0.0, 0.0, 0.0, 0.0, 185.0, 185.0, 183.0, 171.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 255.0, 255.0, 255.0,
        255.0, 0.0, 0.0, 0.0, 0.0, 255.0, 255.0, 255.0, 255.0, 0.0, 0.0, 0.0, 0.0, 255.0, 255.0,
        255.0, 255.0, 0.0, 0.0, 0.0, 0.0, 255.0, 255.0, 255.0, 255.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    ];

    let mut stats = [0.0f32; 15];

    let set = PixelSet {
        pixels,
        block_width: 4,
        block_height: 4,
    };

    set.compute_moments(&mut stats, 4);

    let expected_stats = [
        558104.0, 548719.0, 543566.0, 761940.0, 540099.0, 535355.0, 748935.0, 530831.0, 741795.0,
        1040400.0, 2988.0, 2937.0, 2909.0, 4080.0, 16.0,
    ];

    assert_eq!(stats, expected_stats);
}

#[test]
fn test_compute_covar_dc() {
    let pixels = [
        190.0, 189.0, 189.0, 185.0, 0.0, 0.0, 0.0, 0.0, 191.0, 189.0, 188.0, 185.0, 0.0, 0.0, 0.0,
        0.0, 188.0, 187.0, 187.0, 183.0, 0.0, 0.0, 0.0, 0.0, 185.0, 185.0, 183.0, 184.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 190.0,
        189.0, 189.0, 177.0, 0.0, 0.0, 0.0, 0.0, 191.0, 189.0, 188.0, 171.0, 0.0, 0.0, 0.0, 0.0,
        188.0, 187.0, 187.0, 162.0, 0.0, 0.0, 0.0, 0.0, 185.0, 185.0, 183.0, 176.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 190.0, 189.0,
        189.0, 172.0, 0.0, 0.0, 0.0, 0.0, 191.0, 189.0, 188.0, 164.0, 0.0, 0.0, 0.0, 0.0, 188.0,
        187.0, 187.0, 151.0, 0.0, 0.0, 0.0, 0.0, 185.0, 185.0, 183.0, 171.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 255.0, 255.0, 255.0,
        255.0, 0.0, 0.0, 0.0, 0.0, 255.0, 255.0, 255.0, 255.0, 0.0, 0.0, 0.0, 0.0, 255.0, 255.0,
        255.0, 255.0, 0.0, 0.0, 0.0, 0.0, 255.0, 255.0, 255.0, 255.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    ];

    let expected_covar = [
        95.0, 234.25, 310.25, 0.0, 975.9375, 1371.6875, 0.0, 1938.4375, 0.0, 0.0,
    ];

    let expected_dc = [186.75, 183.5625, 181.8125, 255.0];

    let block = PixelSet {
        pixels,
        block_width: 4,
        block_height: 4,
    };

    let mut covar = [0.0; 10];
    let mut dc = [0.0; 4];
    let zero_based = false;
    let channels = 4;

    block.compute_covar_dc(&mut covar, &mut dc, zero_based, channels);

    for i in 0..10 {
        assert!(
            (covar[i] - expected_covar[i]).abs() < 0.001,
            "Covariance matrix mismatch at index {}: expected {}, got {}",
            i,
            expected_covar[i],
            covar[i]
        );
    }

    for i in 0..4 {
        assert!(
            (dc[i] - expected_dc[i]).abs() < 0.001,
            "DC value mismatch at index {}: expected {}, got {}",
            i,
            expected_dc[i],
            dc[i]
        );
    }
}

#[test]
#[rustfmt::skip]
fn test_compute_metrics() {
    let pixels = [
        190.0, 189.0, 189.0, 185.0, 0.0, 0.0, 0.0, 0.0, 191.0, 189.0, 188.0, 185.0, 0.0, 0.0, 0.0,
        0.0, 188.0, 187.0, 187.0, 183.0, 0.0, 0.0, 0.0, 0.0, 185.0, 185.0, 183.0, 184.0, 0.0, 0.0,
        0.0, -143.816_9, -0.0, 0.0, 0.0, -143.809_57, -143.811_52, -143.812_99, 0.0, -143.813_02,
        0.0, -143.812_74, -143.814_7, 0.0, 0.0, 0.0, 0.0, -143.814_7, 0.0, 0.0, 0.0, -0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -f32::NAN, -0.0, -143.81653, -143.82031, 0.0, 190.0, 189.0,
        189.0, 177.0, -143.82031, 0.0, -0.0, 0.0, 191.0, 189.0, 188.0, 171.0, 0.0, 0.0, 0.0, 0.0,
        188.0, 187.0, 187.0, 162.0, 0.0, 0.0, 0.0, 0.0, 185.0, 185.0, 183.0, 176.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        -143.83641, -143.83641, 0.0, 0.0, 0.0, 0.0, -143.86035, -143.83838, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 190.0, 189.0, 189.0, 172.0, 0.0, 0.0, 0.0, 0.0, 191.0, 189.0, 188.0,
        164.0, 0.0, 0.0, 0.0, 0.0, 188.0, 187.0, 187.0, 151.0, 0.0, 0.0, 0.0, 0.0, 185.0, 185.0,
        183.0, 171.0, -143.83911, -143.84106, -143.84253, -143.84045, -143.84256, 0.0, -143.84229,
        -143.84424, 0.0, 0.0, 0.0, 0.0, -143.84424, 0.0, 0.0, 0.0, -0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 255.0, 255.0, 255.0,
        255.0, 0.0, 0.0, 0.0, 0.0, 255.0, 255.0, 255.0, 255.0, -5845416935424.0, -5647261237248.0,
        -5845416935424.0, -5600813514752.0, 255.0, 255.0, 255.0, 255.0, -5841012916224.0,
        -5600637353984.0, 0.0, 0.0, 255.0, 255.0, 255.0, 255.0, 0.0, 0.0, 0.0, -5647261237248.0,
        -5600637353984.0, 0.0, 0.0, 0.0, -5841021304832.0, -5841012916224.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -105469106119047030767616.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -105458729825505569144832.0, 0.0, -143.93652,
    ];

    let mut state = ModeRankerASTC::new(&ASTCSettings {
        block_width: 4,
        block_height: 4,
        channels: 4,
        fast_skip_threshold: 4,
        refine_iterations: 2,
    });

    state.compute_metrics(&pixels);

    let expected_pca_error = [
        [45.888298, 3.5272427, 44.185722, 36.584255, 45.888298],
        [1634.6777, 1482.7738, 1367.7166, 679.65784, 755.4575],
    ];
    let expected_alpha_error = [
        [0.0, 0.0, 0.0, 0.0, 0.0],
        [-536.4261, -706.44025, -325.68228, -190.46878, 0.0],
    ];
    let expected_sq_norm = [
        [2503.0725, 2504.725, 2502.9565, 2504.4443, 2503.0725],
        [1192.6237, 1269.6577, 1419.7146, 1948.0879, 1955.0496],
    ];
    let expected_scale_error = [
        [1297.3456,639.1848,422.21603,0.0,0.0,0.0,0.0],
        [1095.1792,356.64328,104.21575,0.0,0.0,0.0,0.0],
        [1040.856,265.8559,0.0,0.0,0.0,0.0,0.0],
        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
    ];

    assert_eq!(expected_pca_error, state.pca_error);
    assert_eq!(expected_alpha_error, state.alpha_error);
    assert_eq!(expected_sq_norm, state.sq_norm);
    assert_eq!(expected_scale_error, state.scale_error);
}

#[test]
fn test_load_mode_parameters() {
    let packed_mode: u32 = 447488;

    let block = AstcBlock::from_mode_parameters(packed_mode, 4);

    assert_eq!(block.width, 8);
    assert_eq!(block.height, 8);
    assert_eq!(block.dual_plane, 0);
    assert_eq!(block.weight_range, 0);
    assert_eq!(block.color_component_selector, 0);
    assert_eq!(block.partitions, 1);
    assert_eq!(block.partition_id, 0);
    assert_eq!(block.color_endpoint_modes[0], 6);
    assert_eq!(block.color_endpoint_pairs, 2);
    assert_eq!(block.endpoint_range, 20);
    assert_eq!(block.channels, 4);
}

#[test]
fn test_estimate_error() {
    let block = AstcBlock {
        width: 8,
        height: 8,
        dual_plane: 0,
        weight_range: 1,
        weights: [0; 64],
        color_component_selector: 0,
        partitions: 1,
        partition_id: 0,
        color_endpoint_pairs: 0,
        channels: 4,
        color_endpoint_modes: [6, 0, 0, 0],
        endpoint_range: 20,
        endpoints: [0; 18],
    };

    let mut mode_ranker = ModeRankerASTC::new(&ASTCSettings {
        block_width: 4,
        block_height: 4,
        channels: 4,
        fast_skip_threshold: 64,
        refine_iterations: 2,
    });

    mode_ranker.pca_error = [
        [45.888298, 3.527243, 44.185722, 36.584255, 45.888298],
        [1_634.677_7, 1_482.773_8, 1_367.716_6, 679.657_84, 755.457_5],
    ];
    mode_ranker.alpha_error = [
        [0.0, 0.0, 0.0, 0.0, 0.0],
        [-536.4261, -706.44025, -325.68228, -190.46878, 0.0],
    ];
    mode_ranker.sq_norm = [
        [2503.0725, 2504.725, 2502.9565, 2504.4443, 2503.0725],
        [1192.6237, 1269.6577, 1419.7146, 1948.0879, 1955.0496],
    ];

    let error = mode_ranker.estimate_error(&block);
    assert_eq!(error, 1696.7235);
}
